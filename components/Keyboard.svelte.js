import './Keyboard.svelte.css.proxy.js';
/* src/components/Keyboard.svelte generated by Svelte v3.29.4 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	set_store_value,
	set_style,
	space,
	subscribe,
	svg_element,
	toggle_class
} from "../_snowpack/pkg/svelte/internal.js";

import { pedalling } from "../stores.js";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i].title;
	child_ctx[27] = list[i].note;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

// (192:8) {#each key as { title, note }}
function create_each_block_1(ctx) {
	let span;
	let span_title_value;
	let span_data_key_value;

	return {
		c() {
			span = element("span");
			attr(span, "title", span_title_value = /*title*/ ctx[26]);
			attr(span, "data-key", span_data_key_value = /*note*/ ctx[27]);
			attr(span, "class", "svelte-1kxl7ga");
			toggle_class(span, "depressed", /*$activeNotes*/ ctx[5].has(/*note*/ ctx[27]) || /*playing*/ ctx[4].has(/*note*/ ctx[27]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$activeNotes, keys, playing*/ 176) {
				toggle_class(span, "depressed", /*$activeNotes*/ ctx[5].has(/*note*/ ctx[27]) || /*playing*/ ctx[4].has(/*note*/ ctx[27]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (190:4) {#each keys as key}
function create_each_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*key*/ ctx[23];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "svelte-1kxl7ga");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*keys, $activeNotes, playing*/ 176) {
				each_value_1 = /*key*/ ctx[23];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let t0;
	let svg0;
	let symbol;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let t1;
	let svg1;
	let use0;
	let t2;
	let svg2;
	let use1;
	let mounted;
	let dispose;
	let each_value = /*keys*/ ctx[7];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			svg0 = svg_element("svg");
			symbol = svg_element("symbol");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			t1 = space();
			svg1 = svg_element("svg");
			use0 = svg_element("use");
			t2 = space();
			svg2 = svg_element("svg");
			use1 = svg_element("use");
			attr(div0, "id", "keys");
			attr(div0, "class", "svelte-1kxl7ga");
			attr(div1, "id", "keyboard");
			attr(div1, "class", "svelte-1kxl7ga");
			attr(path0, "d", "M10 0v5.7c0 .9.3 2.2 1 3.5.7 1.4 1.4 3.3 1.4 4.3 0 1.3-1.9 2.8-6.2 2.8-4.4 0-6.2-1.5-6.2-2.8 0-1 .6-2.9 1.4-4.3a28.2 14.1 0 0 0 1-3.5V0z");
			set_style(path0, "fill", "#996a01");
			attr(path1, "d", "m10.5 9-.7-1.7c-.2-.7-.2-1.3-.2-1.8V0h-7v5.5c0 .5 0 1.1-.2 1.8L1.7 9a43 21.5 0 0 0-1.3 4.3c0 1.3 1.7 2.9 5.6 2.9 4.1 0 5.8-1.6 5.8-3 0-1-.5-2.8-1.3-4.2");
			set_style(path1, "fill", "#eed072");
			attr(path2, "d", "M9.1 0v5.2a8 8 0 0 0 .8 4c.7 1.5 1 3.3 1 4.3 0 .8-.9 2.4-4.7 2.4-3.8 0-4.8-1.6-4.8-2.4 0-1 .4-2.8 1.1-4.2.7-1.6.7-3 .7-4V0z");
			set_style(path2, "fill", "#d7a735");
			attr(path3, "d", "M10.5 13.5v-.6c0-.6-.4-.4-.5 0-.2.3-1 1.9-3.8 1.9s-3.7-1.6-4-2c0-.3-.3-.5-.4 0v.7c0 .7.8 2.2 4.4 2.2 3.4 0 4.3-1.5 4.3-2.2");
			set_style(path3, "fill", "#eed072");
			attr(path4, "d", "M6.1 15.2c.5 0 1.3 0 1.7-.2.5 0 1 0 .6.2a3.1 1.6 0 0 1-2.3.4c-.9 0-1.8-.2-2.2-.4-.4-.3 0-.3.6-.2l1.6.2");
			set_style(path4, "fill", "#fff");
			attr(symbol, "id", "pedal");
			attr(symbol, "viewBox", "0 0 12.4 16.3");
			set_style(svg0, "display", "none");
			attr(use0, "href", "#pedal");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "width", "46.9");
			attr(svg1, "height", "61.6");
			attr(svg1, "class", "pedal svelte-1kxl7ga");
			toggle_class(svg1, "depressed", /*$pedalling*/ ctx[6].soft);
			attr(use1, "href", "#pedal");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "width", "46.9");
			attr(svg2, "height", "61.6");
			attr(svg2, "class", "pedal svelte-1kxl7ga");
			toggle_class(svg2, "depressed", /*$pedalling*/ ctx[6].sustain);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			insert(target, t0, anchor);
			insert(target, svg0, anchor);
			append(svg0, symbol);
			append(symbol, path0);
			append(symbol, path1);
			append(symbol, path2);
			append(symbol, path3);
			append(symbol, path4);
			insert(target, t1, anchor);
			insert(target, svg1, anchor);
			append(svg1, use0);
			insert(target, t2, anchor);
			insert(target, svg2, anchor);
			append(svg2, use1);

			if (!mounted) {
				dispose = [
					listen(window, "mouseup", /*mouseup_handler*/ ctx[10]),
					listen(div0, "mousedown", prevent_default(/*mousedown_handler*/ ctx[11])),
					listen(div0, "mouseup", prevent_default(/*mouseup_handler_1*/ ctx[12])),
					listen(div0, "mousemove", prevent_default(/*mousemove_handler*/ ctx[13])),
					listen(svg1, "mousedown", /*mousedown_handler_1*/ ctx[14]),
					listen(svg1, "mouseup", /*mouseup_handler_2*/ ctx[15]),
					listen(svg1, "mouseout", /*mouseout_handler*/ ctx[16]),
					listen(svg2, "mousedown", /*mousedown_handler_2*/ ctx[17]),
					listen(svg2, "mouseup", /*mouseup_handler_3*/ ctx[18]),
					listen(svg2, "mouseout", /*mouseout_handler_1*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*keys, $activeNotes, playing*/ 176) {
				each_value = /*keys*/ ctx[7];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$pedalling*/ 64) {
				toggle_class(svg1, "depressed", /*$pedalling*/ ctx[6].soft);
			}

			if (dirty & /*$pedalling*/ 64) {
				toggle_class(svg2, "depressed", /*$pedalling*/ ctx[6].sustain);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(svg0);
			if (detaching) detach(t1);
			if (detaching) detach(svg1);
			if (detaching) detach(t2);
			if (detaching) detach(svg2);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $activeNotes,
		$$unsubscribe_activeNotes = noop,
		$$subscribe_activeNotes = () => ($$unsubscribe_activeNotes(), $$unsubscribe_activeNotes = subscribe(activeNotes, $$value => $$invalidate(5, $activeNotes = $$value)), activeNotes);

	let $pedalling;
	component_subscribe($$self, pedalling, $$value => $$invalidate(6, $pedalling = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_activeNotes());
	let { keyCount = 88 } = $$props;
	let { startNote } = $$props;
	let { stopNote } = $$props;
	let { activeNotes } = $$props;
	$$subscribe_activeNotes();
	const notes = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
	const keys = [];
	let keyNumber = 1;
	let octave = 0;

	while (keyNumber <= keyCount) {
		for (let i = 0; i < notes.length; i += 1) {
			const note = notes[i];
			if (note === "C") octave += 1;
			if (keyNumber > keyCount) break;

			if (note.endsWith("#")) {
				keys[keys.length - 1].push({
					note: keyNumber + 20,
					title: `${note}${octave}`
				});
			} else {
				keys.push([
					{
						note: keyNumber + 20,
						title: `${note}${octave}`
					}
				]);
			}

			keyNumber += 1;
		}
	}

	let mouseDown = false;
	let playing = new Set();

	const stopPlaying = () => {
		playing.forEach(note => stopNote(note));
		$$invalidate(4, playing = new Set());
	};

	const mouseup_handler = () => {
		stopPlaying();
		$$invalidate(3, mouseDown = false);
	};

	const mousedown_handler = ({ target }) => {
		const note = parseInt(target.dataset.key, 10);
		$$invalidate(3, mouseDown = true);
		$$invalidate(4, playing = playing.add(note));
		startNote(note);
	};

	const mouseup_handler_1 = ({ target }) => {
		const note = parseInt(target.dataset.key, 10);
		playing.delete(note);
		$$invalidate(4, playing);
		stopNote(note);
	};

	const mousemove_handler = ({ target }) => {
		if (mouseDown) {
			const note = parseInt(target.dataset.key, 10);

			if (note && !playing.has(note)) {
				stopPlaying();
				$$invalidate(4, playing = playing.add(note));
				startNote(note);
			}
		}
	};

	const mousedown_handler_1 = () => set_store_value(pedalling, $pedalling.soft = true, $pedalling);
	const mouseup_handler_2 = () => set_store_value(pedalling, $pedalling.soft = false, $pedalling);
	const mouseout_handler = () => set_store_value(pedalling, $pedalling.soft = false, $pedalling);
	const mousedown_handler_2 = () => set_store_value(pedalling, $pedalling.sustain = true, $pedalling);
	const mouseup_handler_3 = () => set_store_value(pedalling, $pedalling.sustain = false, $pedalling);
	const mouseout_handler_1 = () => set_store_value(pedalling, $pedalling.sustain = false, $pedalling);

	$$self.$$set = $$props => {
		if ("keyCount" in $$props) $$invalidate(9, keyCount = $$props.keyCount);
		if ("startNote" in $$props) $$invalidate(0, startNote = $$props.startNote);
		if ("stopNote" in $$props) $$invalidate(1, stopNote = $$props.stopNote);
		if ("activeNotes" in $$props) $$subscribe_activeNotes($$invalidate(2, activeNotes = $$props.activeNotes));
	};

	return [
		startNote,
		stopNote,
		activeNotes,
		mouseDown,
		playing,
		$activeNotes,
		$pedalling,
		keys,
		stopPlaying,
		keyCount,
		mouseup_handler,
		mousedown_handler,
		mouseup_handler_1,
		mousemove_handler,
		mousedown_handler_1,
		mouseup_handler_2,
		mouseout_handler,
		mousedown_handler_2,
		mouseup_handler_3,
		mouseout_handler_1
	];
}

class Keyboard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			keyCount: 9,
			startNote: 0,
			stopNote: 1,
			activeNotes: 2
		});
	}
}

export default Keyboard;
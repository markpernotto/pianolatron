import './Keyboard.svelte.css.proxy.js';
/* src/components/Keyboard.svelte generated by Svelte v3.29.4 */
import {
	SvelteComponent,
	append,
	attr,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	space,
	subscribe,
	toggle_class
} from "../_snowpack/pkg/svelte/internal.js";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i].title;
	child_ctx[20] = list[i].note;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (181:8) {#each key as { title, note }}
function create_each_block_1(ctx) {
	let span;
	let span_title_value;
	let span_data_key_value;

	return {
		c() {
			span = element("span");
			attr(span, "title", span_title_value = /*title*/ ctx[19]);
			attr(span, "data-key", span_data_key_value = /*note*/ ctx[20]);
			attr(span, "class", "svelte-w5nq4k");
			toggle_class(span, "depressed", /*$activeNotes*/ ctx[5].has(/*note*/ ctx[20]) || /*playing*/ ctx[4].has(/*note*/ ctx[20]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$activeNotes, keys, playing*/ 112) {
				toggle_class(span, "depressed", /*$activeNotes*/ ctx[5].has(/*note*/ ctx[20]) || /*playing*/ ctx[4].has(/*note*/ ctx[20]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (179:4) {#each keys as key}
function create_each_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*key*/ ctx[16];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "svelte-w5nq4k");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*keys, $activeNotes, playing*/ 112) {
				each_value_1 = /*key*/ ctx[16];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let mounted;
	let dispose;
	let each_value = /*keys*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "id", "keys");
			attr(div0, "class", "svelte-w5nq4k");
			attr(div1, "id", "keyboard");
			attr(div1, "class", "svelte-w5nq4k");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			if (!mounted) {
				dispose = [
					listen(window, "mouseup", /*mouseup_handler*/ ctx[9]),
					listen(div0, "mousedown", prevent_default(/*mousedown_handler*/ ctx[10])),
					listen(div0, "mouseup", prevent_default(/*mouseup_handler_1*/ ctx[11])),
					listen(div0, "mousemove", prevent_default(/*mousemove_handler*/ ctx[12]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*keys, $activeNotes, playing*/ 112) {
				each_value = /*keys*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $activeNotes,
		$$unsubscribe_activeNotes = noop,
		$$subscribe_activeNotes = () => ($$unsubscribe_activeNotes(), $$unsubscribe_activeNotes = subscribe(activeNotes, $$value => $$invalidate(5, $activeNotes = $$value)), activeNotes);

	$$self.$$.on_destroy.push(() => $$unsubscribe_activeNotes());
	let { keyCount = 88 } = $$props;
	let { startNote } = $$props;
	let { stopNote } = $$props;
	let { activeNotes } = $$props;
	$$subscribe_activeNotes();
	const notes = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
	const keys = [];
	let keyNumber = 1;
	let octave = 0;

	while (keyNumber <= keyCount) {
		for (let i = 0; i < notes.length; i += 1) {
			const note = notes[i];
			if (note === "C") octave += 1;
			if (keyNumber > keyCount) break;

			if (note.endsWith("#")) {
				keys[keys.length - 1].push({
					note: keyNumber + 20,
					title: `${note}${octave}`
				});
			} else {
				keys.push([
					{
						note: keyNumber + 20,
						title: `${note}${octave}`
					}
				]);
			}

			keyNumber += 1;
		}
	}

	let mouseDown = false;
	let playing = new Set();

	const stopPlaying = () => {
		playing.forEach(note => stopNote(note));
		$$invalidate(4, playing = new Set());
	};

	const mouseup_handler = () => {
		stopPlaying();
		$$invalidate(3, mouseDown = false);
	};

	const mousedown_handler = ({ target }) => {
		const note = parseInt(target.dataset.key, 10);
		$$invalidate(3, mouseDown = true);
		$$invalidate(4, playing = playing.add(note));
		startNote(note);
	};

	const mouseup_handler_1 = ({ target }) => {
		const note = parseInt(target.dataset.key, 10);
		playing.delete(note);
		$$invalidate(4, playing);
		stopNote(note);
	};

	const mousemove_handler = ({ target }) => {
		if (mouseDown) {
			const note = parseInt(target.dataset.key, 10);

			if (note && !playing.has(note)) {
				stopPlaying();
				$$invalidate(4, playing = playing.add(note));
				startNote(note);
			}
		}
	};

	$$self.$$set = $$props => {
		if ("keyCount" in $$props) $$invalidate(8, keyCount = $$props.keyCount);
		if ("startNote" in $$props) $$invalidate(0, startNote = $$props.startNote);
		if ("stopNote" in $$props) $$invalidate(1, stopNote = $$props.stopNote);
		if ("activeNotes" in $$props) $$subscribe_activeNotes($$invalidate(2, activeNotes = $$props.activeNotes));
	};

	return [
		startNote,
		stopNote,
		activeNotes,
		mouseDown,
		playing,
		$activeNotes,
		keys,
		stopPlaying,
		keyCount,
		mouseup_handler,
		mousedown_handler,
		mouseup_handler_1,
		mousemove_handler
	];
}

class Keyboard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			keyCount: 8,
			startNote: 0,
			stopNote: 1,
			activeNotes: 2
		});
	}
}

export default Keyboard;
/* src/components/RollViewerControls.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	create_bidirectional_transition,
	detach,
	element,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	space,
	svg_element
} from "../_snowpack/pkg/svelte/internal.js";

import { onMount } from "../_snowpack/pkg/svelte.js";
import { fade } from "../_snowpack/pkg/svelte/transition.js";
import OpenSeadragon from "../_snowpack/pkg/openseadragon.js";
import { easingInterval } from "../utils.js";

function create_fragment(ctx) {
	let div0;
	let button0;
	let svg0;
	let line0;
	let line1;
	let button0_disabled_value;
	let t0;
	let button1;
	let svg1;
	let line2;
	let button1_disabled_value;
	let t1;
	let button2;
	let svg2;
	let polyline0;
	let polyline1;
	let line3;
	let line4;
	let button2_disabled_value;
	let div0_transition;
	let t2;
	let div1;
	let button3;
	let button3_disabled_value;
	let t3;
	let button4;
	let button4_disabled_value;
	let div1_transition;
	let current;
	let mounted;
	let dispose;

	return {
		c() {
			div0 = element("div");
			button0 = element("button");
			svg0 = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t0 = space();
			button1 = element("button");
			svg1 = svg_element("svg");
			line2 = svg_element("line");
			t1 = space();
			button2 = element("button");
			svg2 = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line3 = svg_element("line");
			line4 = svg_element("line");
			t2 = space();
			div1 = element("div");
			button3 = element("button");
			button3.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="16" y1="9" x2="12" y2="5"></line><line x1="8" y1="9" x2="12" y2="5"></line></svg>`;
			t3 = space();
			button4 = element("button");
			button4.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="16" y1="15" x2="12" y2="19"></line><line x1="8" y1="15" x2="12" y2="19"></line></svg>`;
			attr(line0, "x1", "12");
			attr(line0, "y1", "5");
			attr(line0, "x2", "12");
			attr(line0, "y2", "19");
			attr(line1, "x1", "5");
			attr(line1, "y1", "12");
			attr(line1, "x2", "19");
			attr(line1, "y2", "12");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "width", "24");
			attr(svg0, "height", "24");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "stroke-width", "2");
			attr(svg0, "stroke", "currentColor");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke-linecap", "round");
			attr(svg0, "stroke-linejoin", "round");
			button0.disabled = button0_disabled_value = /*currentZoom*/ ctx[4] >= /*maxZoomLevel*/ ctx[0];
			attr(line2, "x1", "5");
			attr(line2, "y1", "12");
			attr(line2, "x2", "19");
			attr(line2, "y2", "12");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "width", "24");
			attr(svg1, "height", "24");
			attr(svg1, "viewBox", "0 0 24 24");
			attr(svg1, "stroke-width", "2");
			attr(svg1, "stroke", "currentColor");
			attr(svg1, "fill", "none");
			attr(svg1, "stroke-linecap", "round");
			attr(svg1, "stroke-linejoin", "round");
			button1.disabled = button1_disabled_value = /*currentZoom*/ ctx[4] <= /*minZoomLevel*/ ctx[1];
			attr(polyline0, "points", "7 8 3 12 7 16");
			attr(polyline1, "points", "17 8 21 12 17 16");
			attr(line3, "x1", "3");
			attr(line3, "y1", "12");
			attr(line3, "x2", "9");
			attr(line3, "y2", "12");
			attr(line4, "x1", "14");
			attr(line4, "y1", "12");
			attr(line4, "x2", "20");
			attr(line4, "y2", "12");
			attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg2, "height", "24");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "stroke-width", "2");
			attr(svg2, "stroke", "currentColor");
			attr(svg2, "fill", "none");
			attr(svg2, "stroke-linecap", "round");
			attr(svg2, "stroke-linejoin", "round");
			button2.disabled = button2_disabled_value = /*currentZoom*/ ctx[4] === 1;
			attr(div0, "class", "overlay-buttons top-center");
			button3.disabled = button3_disabled_value = false;
			button4.disabled = button4_disabled_value = false;
			attr(div1, "class", "overlay-buttons middle-right");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, button0);
			append(button0, svg0);
			append(svg0, line0);
			append(svg0, line1);
			append(div0, t0);
			append(div0, button1);
			append(button1, svg1);
			append(svg1, line2);
			append(div0, t1);
			append(div0, button2);
			append(button2, svg2);
			append(svg2, polyline0);
			append(svg2, polyline1);
			append(svg2, line3);
			append(svg2, line4);
			insert(target, t2, anchor);
			insert(target, div1, anchor);
			append(div1, button3);
			append(div1, t3);
			append(div1, button4);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "mouseup", /*mouseup_handler*/ ctx[9]),
					listen(button0, "click", /*click_handler*/ ctx[10]),
					listen(button1, "click", /*click_handler_1*/ ctx[11]),
					listen(button2, "click", /*click_handler_2*/ ctx[12]),
					listen(button3, "mousedown", /*mousedown_handler*/ ctx[13]),
					listen(button4, "mousedown", /*mousedown_handler_1*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*currentZoom, maxZoomLevel*/ 17 && button0_disabled_value !== (button0_disabled_value = /*currentZoom*/ ctx[4] >= /*maxZoomLevel*/ ctx[0])) {
				button0.disabled = button0_disabled_value;
			}

			if (!current || dirty & /*currentZoom, minZoomLevel*/ 18 && button1_disabled_value !== (button1_disabled_value = /*currentZoom*/ ctx[4] <= /*minZoomLevel*/ ctx[1])) {
				button1.disabled = button1_disabled_value;
			}

			if (!current || dirty & /*currentZoom*/ 16 && button2_disabled_value !== (button2_disabled_value = /*currentZoom*/ ctx[4] === 1)) {
				button2.disabled = button2_disabled_value;
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, true);
				div0_transition.run(1);
			});

			add_render_callback(() => {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
				div1_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, false);
			div0_transition.run(0);
			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
			div1_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching && div0_transition) div0_transition.end();
			if (detaching) detach(t2);
			if (detaching) detach(div1);
			if (detaching && div1_transition) div1_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { openSeadragon } = $$props;
	let { maxZoomLevel } = $$props;
	let { minZoomLevel } = $$props;
	let { strafing } = $$props;
	let { panByIncrement } = $$props;
	let panInterval;
	const { viewport } = openSeadragon;
	let currentZoom = viewport.getZoom();

	const centerRoll = () => {
		const viewportBounds = viewport.getBounds();
		const lineCenter = new OpenSeadragon.Point(0.5, viewportBounds.y + viewportBounds.height / 2);
		$$invalidate(7, strafing = true);
		viewport.panTo(lineCenter);
		setTimeout(() => $$invalidate(7, strafing = false), 1000);
	};

	const onZoom = () => $$invalidate(4, currentZoom = viewport.getZoom());

	onMount(() => {
		openSeadragon.addHandler("zoom", onZoom);

		return () => {
			openSeadragon.removeHandler("zoom", onZoom);
			panInterval?.clear();
		};
	});

	const mouseup_handler = () => panInterval?.clear();
	const click_handler = () => viewport.zoomTo(Math.min(viewport.getZoom() * 1.1, maxZoomLevel));
	const click_handler_1 = () => viewport.zoomTo(Math.max(viewport.getZoom() * 0.9, minZoomLevel));

	const click_handler_2 = () => {
		viewport.zoomTo(1);
		centerRoll();
	};

	const mousedown_handler = () => {
		panByIncrement(false);
		$$invalidate(3, panInterval = easingInterval(200, () => panByIncrement(false)));
	};

	const mousedown_handler_1 = () => {
		panByIncrement(true);
		$$invalidate(3, panInterval = easingInterval(200, () => panByIncrement(true)));
	};

	$$self.$$set = $$props => {
		if ("openSeadragon" in $$props) $$invalidate(8, openSeadragon = $$props.openSeadragon);
		if ("maxZoomLevel" in $$props) $$invalidate(0, maxZoomLevel = $$props.maxZoomLevel);
		if ("minZoomLevel" in $$props) $$invalidate(1, minZoomLevel = $$props.minZoomLevel);
		if ("strafing" in $$props) $$invalidate(7, strafing = $$props.strafing);
		if ("panByIncrement" in $$props) $$invalidate(2, panByIncrement = $$props.panByIncrement);
	};

	return [
		maxZoomLevel,
		minZoomLevel,
		panByIncrement,
		panInterval,
		currentZoom,
		viewport,
		centerRoll,
		strafing,
		openSeadragon,
		mouseup_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		mousedown_handler,
		mousedown_handler_1
	];
}

class RollViewerControls extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			openSeadragon: 8,
			maxZoomLevel: 0,
			minZoomLevel: 1,
			strafing: 7,
			panByIncrement: 2
		});
	}
}

export default RollViewerControls;
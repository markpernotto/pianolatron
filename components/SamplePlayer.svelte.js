/* src/components/SamplePlayer.svelte generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	component_subscribe,
	init,
	safe_not_equal
} from "../_snowpack/pkg/svelte/internal.js";

import MidiPlayer from "../_snowpack/pkg/midi-player-js.js";
import { Piano } from "../_snowpack/pkg/@tonejs/piano.js";
import IntervalTree from "../_snowpack/pkg/node-interval-tree.js";

import {
	rollMetadata,
	softOnOff,
	sustainOnOff,
	accentOnOff,
	volumeCoefficient,
	bassVolumeCoefficient,
	trebleVolumeCoefficient,
	tempoCoefficient,
	playExpressionsOnOff,
	rollPedalingOnOff,
	useMidiTempoEventsOnOff,
	activeNotes,
	currentTick
} from "../stores.js";

const SOFT_PEDAL = 67;
const SUSTAIN_PEDAL = 64;
const DEFAULT_NOTE_VELOCITY = 50;
const DEFAULT_TEMPO = 60;
const SOFT_PEDAL_RATIO = 0.67;
const HALF_BOUNDARY = 66; // F# above Middle C; divides the keyboard into two "pans"
const ACCENT_BUMP = 1.5;

function instance($$self, $$props, $$invalidate) {
	let $useMidiTempoEventsOnOff;
	let $currentTick;
	let $tempoCoefficient;
	let $rollPedalingOnOff;
	let $playExpressionsOnOff;
	let $softOnOff;
	let $accentOnOff;
	let $volumeCoefficient;
	let $bassVolumeCoefficient;
	let $trebleVolumeCoefficient;
	let $sustainOnOff;
	let $activeNotes;
	component_subscribe($$self, useMidiTempoEventsOnOff, $$value => $$invalidate(8, $useMidiTempoEventsOnOff = $$value));
	component_subscribe($$self, currentTick, $$value => $$invalidate(15, $currentTick = $$value));
	component_subscribe($$self, tempoCoefficient, $$value => $$invalidate(9, $tempoCoefficient = $$value));
	component_subscribe($$self, rollPedalingOnOff, $$value => $$invalidate(10, $rollPedalingOnOff = $$value));
	component_subscribe($$self, playExpressionsOnOff, $$value => $$invalidate(16, $playExpressionsOnOff = $$value));
	component_subscribe($$self, softOnOff, $$value => $$invalidate(17, $softOnOff = $$value));
	component_subscribe($$self, accentOnOff, $$value => $$invalidate(18, $accentOnOff = $$value));
	component_subscribe($$self, volumeCoefficient, $$value => $$invalidate(19, $volumeCoefficient = $$value));
	component_subscribe($$self, bassVolumeCoefficient, $$value => $$invalidate(20, $bassVolumeCoefficient = $$value));
	component_subscribe($$self, trebleVolumeCoefficient, $$value => $$invalidate(21, $trebleVolumeCoefficient = $$value));
	component_subscribe($$self, sustainOnOff, $$value => $$invalidate(11, $sustainOnOff = $$value));
	component_subscribe($$self, activeNotes, $$value => $$invalidate(22, $activeNotes = $$value));
	let tempoMap;
	let pedalingMap;
	let notesMap;
	const midiSamplePlayer = new MidiPlayer.Player();

	const piano = new Piano({
			url: "assets/samples/",
			velocities: 4,
			release: true,
			pedal: true,
			maxPolyphony: 64,
			volume: {
				strings: -15,
				harmonics: -10,
				pedal: -10,
				keybed: -10
			}
		}).toDestination();

	const pianoReady = piano.load();

	const getTempoAtTick = tick => {
		if (!tempoMap || !$useMidiTempoEventsOnOff) return DEFAULT_TEMPO;
		let tempo;
		let i = 0;

		while (tempoMap[i][0] <= tick) {
			[,tempo] = tempoMap[i];
			i += 1;
			if (i >= tempoMap.length) break;
		}

		return tempo;
	};

	const setPlayerStateAtTick = (tick = $currentTick) => {
		if (midiSamplePlayer.tracks[0]) $$invalidate(0, midiSamplePlayer.tracks[0].enabled = $useMidiTempoEventsOnOff, midiSamplePlayer);
		midiSamplePlayer.setTempo(getTempoAtTick(tick) * $tempoCoefficient);

		if (pedalingMap && $rollPedalingOnOff) {
			const pedals = pedalingMap.search($currentTick, $currentTick);
			sustainOnOff.set(pedals.includes(SUSTAIN_PEDAL));
			softOnOff.set(pedals.includes(SOFT_PEDAL));
		} else {
			sustainOnOff.set(false);
			piano.pedalUp();
			softOnOff.set(false);
		}

		if (notesMap) {
			activeNotes.reset(notesMap.search($currentTick, $currentTick));
		}
	};

	const updatePlayer = (fn = () => {
			
		}) => {
		if (midiSamplePlayer.isPlaying()) {
			midiSamplePlayer.pause();
			fn();
			setPlayerStateAtTick($currentTick);
			midiSamplePlayer.play();
			return;
		}

		fn();
		setPlayerStateAtTick($currentTick);
	};

	const startNote = (noteNumber, velocity) => {
		const modifiedVelocity = ($playExpressionsOnOff && velocity || DEFAULT_NOTE_VELOCITY) / 100 * ($softOnOff && SOFT_PEDAL_RATIO || 1) * ($accentOnOff && ACCENT_BUMP || 1) * $volumeCoefficient * (noteNumber < HALF_BOUNDARY
		? $bassVolumeCoefficient
		: $trebleVolumeCoefficient);

		if (modifiedVelocity) {
			piano.keyDown({
				midi: noteNumber,
				velocity: Math.min(modifiedVelocity, 1)
			});
		}
	};

	const stopNote = noteNumber => piano.keyUp({ midi: noteNumber });

	const stopAllNotes = () => {
		piano.pedalUp();
		if ($sustainOnOff) piano.pedalDown();
		$activeNotes.forEach(stopNote);
	};

	const resetPlayback = () => {
		currentTick.reset();
		midiSamplePlayer.stop();
		activeNotes.reset();
		softOnOff.reset();
		sustainOnOff.reset();
		accentOnOff.reset();
	};

	const pausePlayback = () => {
		midiSamplePlayer.pause();
		stopAllNotes();
	};

	const startPlayback = () => {
		if ($currentTick < 0) resetPlayback();
		updatePlayer();
		midiSamplePlayer.play();
	};

	const buildTempoMap = metadataTrack => metadataTrack.filter(event => event.name === "Set Tempo").reduce(
		(_tempoMap, { tick, data }) => {
			if (!_tempoMap.map(([,_data]) => _data).includes(data)) _tempoMap.push([tick, data]);
			return _tempoMap;
		},
		[]
	);

	const buildPedalingMap = eventsTrack => {
		const _pedalingMap = new IntervalTree();
		const controllerEvents = eventsTrack.filter(event => event.name === "Controller Change");

		const enterEvents = eventNumber => {
			let tickOn = false;

			controllerEvents.filter(({ number }) => number === eventNumber).forEach(({ value, tick }) => {
				if (value === 0) {
					if (tickOn) _pedalingMap.insert(tickOn, tick, eventNumber);
					tickOn = false;
				} else if (value === 127) {
					if (!tickOn) tickOn = tick;
				}
			});
		};

		enterEvents(SOFT_PEDAL);
		enterEvents(SUSTAIN_PEDAL);
		return _pedalingMap;
	};

	const buildNotesMap = musicTracks => {
		const _notesMap = new IntervalTree();

		musicTracks.forEach(track => {
			const tickOn = {};

			track.filter(event => event.name === "Note on").forEach(({ noteNumber, velocity, tick }) => {
				if (velocity === 0) {
					if (noteNumber in tickOn) {
						_notesMap.insert(tickOn[noteNumber], tick, noteNumber);
						delete tickOn[noteNumber];
					}
				} else if (!(noteNumber in tickOn)) tickOn[noteNumber] = tick;
			});
		});

		return _notesMap;
	};

	midiSamplePlayer.on("fileLoaded", () => {
		const decodeHtmlEntities = string => string.replace(/&#(\d+);/g, (match, num) => String.fromCodePoint(num)).replace(/&#x([A-Za-z0-9]+);/g, (match, num) => String.fromCodePoint(parseInt(num, 16)));
		const [metadataTrack, ...musicTracks] = midiSamplePlayer.events;
		rollMetadata.set(Object.fromEntries(metadataTrack.filter(event => event.name === "Text Event").map(event => event.string.match(/^@([^:]*):[\t\s]*(.*)$/).slice(1, 3).map(decodeHtmlEntities))));
		tempoMap = buildTempoMap(metadataTrack);

		// where two or more "music tracks" exist, pedal events are expected to have
		//  been duplicated across tracks, so we read only from the first one.
		pedalingMap = buildPedalingMap(musicTracks[0]);

		notesMap = buildNotesMap(musicTracks);
	});

	midiSamplePlayer.on("playing", ({ tick }) => {
		if (tick <= midiSamplePlayer.totalTicks) currentTick.set(tick);
	});

	midiSamplePlayer.on("midiEvent", ({ name, value, number, noteNumber, velocity, data }) => {
		if (name === "Note on") {
			if (velocity === 0) {
				stopNote(noteNumber);
				activeNotes.delete(noteNumber);
			} else {
				startNote(noteNumber, velocity);
				activeNotes.add(noteNumber);
			}
		} else if (name === "Controller Change" && $rollPedalingOnOff) {
			if (number === SUSTAIN_PEDAL) {
				sustainOnOff.set(!!value);
			} else if (number === SOFT_PEDAL) {
				softOnOff.set(!!value);
			}
		} else if (name === "Set Tempo" && $useMidiTempoEventsOnOff) {
			midiSamplePlayer.setTempo(data * $tempoCoefficient);
		}
	});

	midiSamplePlayer.on("endOfFile", pausePlayback);

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$sustainOnOff*/ 2048) {
			/* eslint-disable no-unused-expressions, no-sequences */
			$: $sustainOnOff ? piano.pedalDown() : piano.pedalUp();
		}

		if ($$self.$$.dirty & /*$tempoCoefficient*/ 512) {
			$: ($tempoCoefficient, updatePlayer());
		}

		if ($$self.$$.dirty & /*$useMidiTempoEventsOnOff*/ 256) {
			$: ($useMidiTempoEventsOnOff, updatePlayer());
		}

		if ($$self.$$.dirty & /*$rollPedalingOnOff*/ 1024) {
			$: ($rollPedalingOnOff, updatePlayer());
		}
	};

	return [
		midiSamplePlayer,
		pianoReady,
		updatePlayer,
		startNote,
		stopNote,
		resetPlayback,
		pausePlayback,
		startPlayback,
		$useMidiTempoEventsOnOff,
		$tempoCoefficient,
		$rollPedalingOnOff,
		$sustainOnOff
	];
}

class SamplePlayer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, null, safe_not_equal, {
			midiSamplePlayer: 0,
			pianoReady: 1,
			updatePlayer: 2,
			startNote: 3,
			stopNote: 4,
			resetPlayback: 5,
			pausePlayback: 6,
			startPlayback: 7
		});
	}

	get midiSamplePlayer() {
		return this.$$.ctx[0];
	}

	get pianoReady() {
		return this.$$.ctx[1];
	}

	get updatePlayer() {
		return this.$$.ctx[2];
	}

	get startNote() {
		return this.$$.ctx[3];
	}

	get stopNote() {
		return this.$$.ctx[4];
	}

	get resetPlayback() {
		return this.$$.ctx[5];
	}

	get pausePlayback() {
		return this.$$.ctx[6];
	}

	get startPlayback() {
		return this.$$.ctx[7];
	}
}

export default SamplePlayer;
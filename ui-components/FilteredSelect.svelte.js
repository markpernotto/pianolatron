import './FilteredSelect.svelte.css.proxy.js';
/* src/ui-components/FilteredSelect.svelte generated by Svelte v3.38.3 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	space,
	stop_propagation,
	toggle_class
} from "../_snowpack/pkg/svelte/internal.js";

import { tick } from "../_snowpack/pkg/svelte.js";
import { clamp } from "../utils.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

// (313:4) {:else}
function create_else_block(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.textContent = "No results found";
			attr(li, "class", "svelte-18jy66v");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (303:4) {#if filteredListItems?.length}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*filteredListItems*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*activeListItemIndex, selectListItem, filteredListItems, postMarkup*/ 75) {
				each_value = /*filteredListItems*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (304:6) {#each filteredListItems as listItem, i}
function create_each_block(ctx) {
	let li;
	let html_tag;
	let raw_value = /*postMarkup*/ ctx[0](/*listItem*/ ctx[30].markedUp || /*listItem*/ ctx[30].label) + "";
	let t;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[18](/*listItem*/ ctx[30]);
	}

	function pointerenter_handler() {
		return /*pointerenter_handler*/ ctx[19](/*i*/ ctx[32]);
	}

	return {
		c() {
			li = element("li");
			html_tag = new HtmlTag();
			t = space();
			html_tag.a = t;
			attr(li, "class", "svelte-18jy66v");
			toggle_class(li, "selected", /*i*/ ctx[32] === /*activeListItemIndex*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			html_tag.m(raw_value, li);
			append(li, t);

			if (!mounted) {
				dispose = [
					listen(li, "click", click_handler_1),
					listen(li, "pointerenter", pointerenter_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*postMarkup, filteredListItems*/ 3 && raw_value !== (raw_value = /*postMarkup*/ ctx[0](/*listItem*/ ctx[30].markedUp || /*listItem*/ ctx[30].label) + "")) html_tag.p(raw_value);

			if (dirty[0] & /*activeListItemIndex*/ 8) {
				toggle_class(li, "selected", /*i*/ ctx[32] === /*activeListItemIndex*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let span;
	let t;
	let ul;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*filteredListItems*/ ctx[1]?.length) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			span = element("span");
			t = space();
			ul = element("ul");
			if_block.c();
			attr(span, "class", "input svelte-18jy66v");
			attr(span, "spellcheck", "false");
			attr(span, "contenteditable", "true");
			attr(ul, "class", "svelte-18jy66v");
			toggle_class(ul, "open", /*open*/ ctx[2]);
			attr(div, "class", "filtered-select svelte-18jy66v");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			/*span_binding*/ ctx[16](span);
			append(div, t);
			append(div, ul);
			if_block.m(ul, null);
			/*ul_binding*/ ctx[20](ul);

			if (!mounted) {
				dispose = [
					listen(window, "click", /*click_handler*/ ctx[15]),
					listen(span, "input", /*search*/ ctx[9]),
					listen(span, "focus", /*activateDropdown*/ ctx[8]),
					listen(span, "click", /*activateDropdown*/ ctx[8]),
					listen(span, "keydown", stop_propagation(/*keydown_handler*/ ctx[17]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(ul, null);
				}
			}

			if (dirty[0] & /*open*/ 4) {
				toggle_class(ul, "open", /*open*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*span_binding*/ ctx[16](null);
			if_block.d();
			/*ul_binding*/ ctx[20](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	let { selectedItem } = $$props;
	let { labelFieldName } = $$props;
	let { searchFieldName = labelFieldName } = $$props;
	let { postMarkup = str => str } = $$props;
	let listItems = [];
	let filteredListItems;
	let open = false;
	let activeListItemIndex = -1;
	let input;
	let list;
	const unDecomposableMap = { ł: "l", ß: "ss", æ: "ae", ø: "o" };
	const unDecomposableRegex = new RegExp(Object.keys(unDecomposableMap).join("|"), "g");
	const longSubstitutionsRegex = new RegExp(Object.keys(unDecomposableMap).filter(k => unDecomposableMap[k].length > 1).join("|"), "gi");
	const normalizeText = str => str.toLowerCase().replace(/\s+/g, " ").replace(unDecomposableRegex, m => unDecomposableMap[m]).normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
	const startIdxAdjustment = (str, idx) => (str.toLowerCase().substring(0, idx).match(longSubstitutionsRegex) || []).length;
	const endIdxAdjustment = (str, idx) => (str.toLowerCase().substring(0, idx).match(longSubstitutionsRegex) || []).reduce((adj, m) => adj + (unDecomposableMap[m].length - m.length), 0);

	const markupMatches = (label, searchContent, searchParts) => {
		const matchExtents = [];
		const mergedExtents = [];
		let markedUp = label;

		searchParts.forEach(searchPart => {
			let idx = -1;

			while ((idx = searchContent.indexOf(searchPart, idx + 1)) > -1) {
				const _idx = idx - startIdxAdjustment(label, idx - 1);
				const _idxEnd = idx + searchPart.length - endIdxAdjustment(label, _idx + searchPart.length - 1);
				matchExtents.push([_idx, _idxEnd]);
			}
		});

		matchExtents.sort((a, b) => a[0] - b[0]).forEach(([start, end]) => {
			const previousExtent = mergedExtents[mergedExtents.length - 1];

			if (previousExtent && previousExtent[1] >= start) {
				previousExtent[1] = Math.max(previousExtent[1], end);
			} else {
				mergedExtents.push([start, end]);
			}
		});

		mergedExtents.sort((a, b) => b[0] - a[0]).forEach(([start, end]) => {
			markedUp = `${markedUp.substring(0, start)}<mark>${markedUp.substring(start, end)}</mark>${markedUp.substring(end)}`;
		});

		return markedUp;
	};

	const selectListItem = (listItem = filteredListItems[activeListItemIndex]) => {
		$$invalidate(11, selectedItem = listItem.item);
		$$invalidate(2, open = false);
	};

	const activateListItem = async index => {
		$$invalidate(3, activeListItemIndex = clamp(index, 0, filteredListItems.length - 1));
		await tick();
		const activeListItem = list.querySelector(".selected");

		if (activeListItem) {
			const { top: listItemTop, bottom: listItemBottom } = activeListItem.getBoundingClientRect();
			const { top: listTop, bottom: listBottom } = list.getBoundingClientRect();
			if (listItemBottom > listBottom) activeListItem.scrollIntoView(false);
			if (listItemTop < listTop) activeListItem.scrollIntoView();
		}
	};

	const activateDropdown = async () => {
		if (open) return;
		$$invalidate(2, open = true);
		await tick();
		$$invalidate(4, input.innerHTML = "", input);
		$$invalidate(1, filteredListItems = listItems);
		activateListItem(items.indexOf(selectedItem));
	};

	const search = async () => {
		$$invalidate(2, open = true);
		$$invalidate(1, filteredListItems = listItems);
		$$invalidate(3, activeListItemIndex = 0);
		if (!input.innerHTML) return;
		const filteredText = normalizeText(input.innerHTML.replace(/[&/\\#,+()$~%.'":*?<>{}]|nbsp;/g, " "));

		if (filteredText) {
			const searchParts = filteredText.split(" ").slice(0, 8);

			$$invalidate(1, filteredListItems = listItems.filter(listItem => searchParts.every(searchPart => listItem.searchContent.includes(searchPart))).map(item => ({
				...item,
				markedUp: markupMatches(item.label, item.searchContent, searchParts)
			})));
		}
	};

	const prepareListItems = () => {
		listItems = items.map(item => ({
			searchContent: normalizeText(searchFieldName ? item[searchFieldName] : item),
			label: labelFieldName ? item[labelFieldName] : item,
			item
		}));
	};

	const onSelectedItemChanged = () => {
		if (input) $$invalidate(
			4,
			input.innerHTML = postMarkup(labelFieldName
			? selectedItem[labelFieldName]
			: selectedItem),
			input
		);
	};

	const click_handler = ({ target, defaultPrevented }) => {
		if (!(list.contains(target) || input.contains(target)) && !defaultPrevented) {
			$$invalidate(2, open = false);
			onSelectedItemChanged();
		}
	};

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(4, input);
		});
	}

	const keydown_handler = ({ key }) => {
		switch (key) {
			case "ArrowDown":
				activateDropdown();
				activateListItem(activeListItemIndex + 1);
				break;
			case "ArrowUp":
				activateDropdown();
				activateListItem(activeListItemIndex - 1);
				break;
			case "PageDown":
				activateDropdown();
				activateListItem(activeListItemIndex + 15);
				break;
			case "PageUp":
				activateDropdown();
				activateListItem(activeListItemIndex - 15);
				break;
			case "Escape":
				if (open) $$invalidate(2, open = false);
				onSelectedItemChanged();
				break;
			case "Enter":
				selectListItem();
				input.blur();
				break;
			default:
		}
	};

	const click_handler_1 = listItem => selectListItem(listItem);
	const pointerenter_handler = i => $$invalidate(3, activeListItemIndex = i);

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			list = $$value;
			$$invalidate(5, list);
		});
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(12, items = $$props.items);
		if ("selectedItem" in $$props) $$invalidate(11, selectedItem = $$props.selectedItem);
		if ("labelFieldName" in $$props) $$invalidate(13, labelFieldName = $$props.labelFieldName);
		if ("searchFieldName" in $$props) $$invalidate(14, searchFieldName = $$props.searchFieldName);
		if ("postMarkup" in $$props) $$invalidate(0, postMarkup = $$props.postMarkup);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 4096) {
			/* eslint-disable no-unused-expressions, no-sequences */
			$: (items, prepareListItems());
		}

		if ($$self.$$.dirty[0] & /*selectedItem*/ 2048) {
			$: (selectedItem, onSelectedItemChanged());
		}
	};

	return [
		postMarkup,
		filteredListItems,
		open,
		activeListItemIndex,
		input,
		list,
		selectListItem,
		activateListItem,
		activateDropdown,
		search,
		onSelectedItemChanged,
		selectedItem,
		items,
		labelFieldName,
		searchFieldName,
		click_handler,
		span_binding,
		keydown_handler,
		click_handler_1,
		pointerenter_handler,
		ul_binding
	];
}

class FilteredSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				items: 12,
				selectedItem: 11,
				labelFieldName: 13,
				searchFieldName: 14,
				postMarkup: 0
			},
			[-1, -1]
		);
	}
}

export default FilteredSelect;
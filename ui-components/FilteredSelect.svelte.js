import './FilteredSelect.svelte.css.proxy.js';
/* src/ui-components/FilteredSelect.svelte generated by Svelte v3.38.3 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	prevent_default,
	run_all,
	safe_not_equal,
	set_data,
	space,
	stop_propagation,
	text,
	toggle_class
} from "../_snowpack/pkg/svelte/internal.js";

import { tick } from "../_snowpack/pkg/svelte.js";
import { clamp } from "../utils.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[42] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

// (362:6) {#if facets}
function create_if_block_1(ctx) {
	let ul;
	let each_value_1 = /*facets*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "svelte-1jalys9");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*facets, activeFacet, setActiveFacet, input*/ 4296) {
				each_value_1 = /*facets*/ ctx[3];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (364:10) {#each facets as facet}
function create_each_block_1(ctx) {
	let li;
	let t0_value = /*facet*/ ctx[43] + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[26](/*facet*/ ctx[43]);
	}

	return {
		c() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			attr(li, "class", "svelte-1jalys9");
			toggle_class(li, "active", /*facet*/ ctx[43] === /*activeFacet*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t0);
			append(li, t1);

			if (!mounted) {
				dispose = listen(li, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*facets*/ 8 && t0_value !== (t0_value = /*facet*/ ctx[43] + "")) set_data(t0, t0_value);

			if (dirty[0] & /*facets, activeFacet*/ 72) {
				toggle_class(li, "active", /*facet*/ ctx[43] === /*activeFacet*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (390:6) {:else}
function create_else_block(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.textContent = "No results found";
			attr(li, "class", "svelte-1jalys9");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (380:6) {#if filteredListItems?.length}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*filteredListItems*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*activeListItemIndex, selectListItem, filteredListItems, postMarkup*/ 65573) {
				each_value = /*filteredListItems*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (381:8) {#each filteredListItems as listItem, i}
function create_each_block(ctx) {
	let li;
	let html_tag;
	let raw_value = /*postMarkup*/ ctx[0](/*listItem*/ ctx[40].markedUp || /*listItem*/ ctx[40].label) + "";
	let t;
	let mounted;
	let dispose;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[27](/*listItem*/ ctx[40]);
	}

	function pointerenter_handler() {
		return /*pointerenter_handler*/ ctx[28](/*i*/ ctx[42]);
	}

	return {
		c() {
			li = element("li");
			html_tag = new HtmlTag();
			t = space();
			html_tag.a = t;
			attr(li, "class", "svelte-1jalys9");
			toggle_class(li, "selected", /*i*/ ctx[42] === /*activeListItemIndex*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			html_tag.m(raw_value, li);
			append(li, t);

			if (!mounted) {
				dispose = [
					listen(li, "click", click_handler_2),
					listen(li, "pointerenter", pointerenter_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*postMarkup, filteredListItems*/ 5 && raw_value !== (raw_value = /*postMarkup*/ ctx[0](/*listItem*/ ctx[40].markedUp || /*listItem*/ ctx[40].label) + "")) html_tag.p(raw_value);

			if (dirty[0] & /*activeListItemIndex*/ 32) {
				toggle_class(li, "selected", /*i*/ ctx[42] === /*activeListItemIndex*/ ctx[5]);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let span;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2_value = /*filteredListItems*/ ctx[2]?.length + "";
	let t2;
	let t3;
	let t4_value = /*listItems*/ ctx[1].length + "";
	let t4;
	let t5;
	let ul;
	let mounted;
	let dispose;
	let if_block0 = /*facets*/ ctx[3] && create_if_block_1(ctx);

	function select_block_type(ctx, dirty) {
		if (/*filteredListItems*/ ctx[2]?.length) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, [-1, -1]);
	let if_block1 = current_block_type(ctx);

	return {
		c() {
			div2 = element("div");
			span = element("span");
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t1 = text("\n      Filtered: ");
			t2 = text(t2_value);
			t3 = text(" / ");
			t4 = text(t4_value);
			t5 = space();
			ul = element("ul");
			if_block1.c();
			attr(span, "class", "input svelte-1jalys9");
			attr(span, "spellcheck", "false");
			attr(span, "contenteditable", "true");
			attr(div0, "class", "facets svelte-1jalys9");
			attr(ul, "class", "items svelte-1jalys9");
			toggle_class(ul, "open", /*open*/ ctx[4]);
			attr(div1, "class", "dropdown svelte-1jalys9");
			toggle_class(div1, "open", /*open*/ ctx[4]);
			attr(div2, "class", "filtered-select svelte-1jalys9");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, span);
			/*span_binding*/ ctx[24](span);
			append(div2, t0);
			append(div2, div1);
			append(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t1);
			append(div0, t2);
			append(div0, t3);
			append(div0, t4);
			append(div1, t5);
			append(div1, ul);
			if_block1.m(ul, null);
			/*ul_binding*/ ctx[29](ul);
			/*div1_binding*/ ctx[30](div1);

			if (!mounted) {
				dispose = [
					listen(window, "click", /*click_handler*/ ctx[22]),
					listen(window, "keydown", stop_propagation(/*keydown_handler*/ ctx[23])),
					listen(span, "input", /*search*/ ctx[11]),
					listen(span, "focus", /*activateDropdown*/ ctx[13]),
					listen(span, "mousedown", prevent_default(/*toggleDropdown*/ ctx[15])),
					listen(span, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[25]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*facets*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div0, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*filteredListItems*/ 4 && t2_value !== (t2_value = /*filteredListItems*/ ctx[2]?.length + "")) set_data(t2, t2_value);
			if (dirty[0] & /*listItems*/ 2 && t4_value !== (t4_value = /*listItems*/ ctx[1].length + "")) set_data(t4, t4_value);

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(ul, null);
				}
			}

			if (dirty[0] & /*open*/ 16) {
				toggle_class(ul, "open", /*open*/ ctx[4]);
			}

			if (dirty[0] & /*open*/ 16) {
				toggle_class(div1, "open", /*open*/ ctx[4]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			/*span_binding*/ ctx[24](null);
			if (if_block0) if_block0.d();
			if_block1.d();
			/*ul_binding*/ ctx[29](null);
			/*div1_binding*/ ctx[30](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	let { selectedItem } = $$props;
	let { labelFieldName } = $$props;
	let { searchFieldName = labelFieldName } = $$props;
	let { facetFieldName } = $$props;
	let { postMarkup = str => str } = $$props;
	let listItems = [];
	let filteredListItems;
	let facets;
	let open = false;
	let activeListItemIndex = -1;
	let activeFacet;
	let input;
	let dropdown;
	let list;
	const unDecomposableMap = { ł: "l", ß: "ss", æ: "ae", ø: "o" };
	const unDecomposableRegex = new RegExp(Object.keys(unDecomposableMap).join("|"), "g");
	const longSubstitutionsRegex = new RegExp(Object.keys(unDecomposableMap).filter(k => unDecomposableMap[k].length > 1).join("|"), "gi");
	const normalizeText = str => str.toLowerCase().replace(/\s+/g, " ").replace(unDecomposableRegex, m => unDecomposableMap[m]).normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
	const startIdxAdjustment = (str, idx) => (str.toLowerCase().substring(0, idx).match(longSubstitutionsRegex) || []).length;
	const endIdxAdjustment = (str, idx) => (str.toLowerCase().substring(0, idx).match(longSubstitutionsRegex) || []).reduce((adj, m) => adj + (unDecomposableMap[m].length - m.length), 0);

	const markupMatches = (label, searchContent, searchParts) => {
		const matchExtents = [];
		const mergedExtents = [];
		let markedUp = label;

		searchParts.forEach(searchPart => {
			let idx = -1;

			while ((idx = searchContent.indexOf(searchPart, idx + 1)) > -1) {
				const _idx = idx - startIdxAdjustment(label, idx - 1);
				const _idxEnd = idx + searchPart.length - endIdxAdjustment(label, _idx + searchPart.length - 1);
				matchExtents.push([_idx, _idxEnd]);
			}
		});

		matchExtents.sort((a, b) => a[0] - b[0]).forEach(([start, end]) => {
			const previousExtent = mergedExtents[mergedExtents.length - 1];

			if (previousExtent && previousExtent[1] >= start) {
				previousExtent[1] = Math.max(previousExtent[1], end);
			} else {
				mergedExtents.push([start, end]);
			}
		});

		mergedExtents.sort((a, b) => b[0] - a[0]).forEach(([start, end]) => {
			markedUp = `${markedUp.substring(0, start)}<mark>${markedUp.substring(start, end)}</mark>${markedUp.substring(end)}`;
		});

		return markedUp;
	};

	const activateListItem = async index => {
		$$invalidate(5, activeListItemIndex = clamp(index, 0, filteredListItems.length - 1));
		await tick();
		const activeListItem = list.querySelector(".selected");

		if (activeListItem) {
			const { top: listItemTop, bottom: listItemBottom } = activeListItem.getBoundingClientRect();
			const { top: listTop, bottom: listBottom } = list.getBoundingClientRect();
			if (listItemBottom > listBottom) activeListItem.scrollIntoView(false);
			if (listItemTop < listTop) activeListItem.scrollIntoView();
		}
	};

	const search = async () => {
		$$invalidate(4, open = true);
		$$invalidate(2, filteredListItems = listItems);
		$$invalidate(5, activeListItemIndex = 0);
		$$invalidate(2, filteredListItems = listItems);
		if (activeFacet) $$invalidate(2, filteredListItems = listItems.filter(listItem => listItem.item[facetFieldName] === activeFacet));
		if (!input.innerHTML) return;
		const filteredText = normalizeText(input.innerHTML.replace(/[&/\\#,+()$~%.'":*?<>{}]|nbsp;/g, " "));

		if (filteredText) {
			const searchParts = filteredText.split(" ").slice(0, 8);

			$$invalidate(2, filteredListItems = filteredListItems.filter(listItem => searchParts.every(searchPart => listItem.searchContent.includes(searchPart))).map(item => ({
				...item,
				markedUp: markupMatches(item.label, item.searchContent, searchParts)
			})));
		}
	};

	const setActiveFacet = async facet => {
		$$invalidate(6, activeFacet = facet === activeFacet ? undefined : facet);
		search();
	};

	const prepareListItems = () => {
		$$invalidate(1, listItems = items.map(item => ({
			searchContent: normalizeText(searchFieldName ? item[searchFieldName] : item),
			label: labelFieldName ? item[labelFieldName] : item,
			item
		})));

		if (facetFieldName) $$invalidate(3, facets = [...new Set(items.map(item => item[facetFieldName]))]);
	};

	const onSelectedItemChanged = () => {
		if (input) $$invalidate(
			7,
			input.innerHTML = postMarkup(labelFieldName
			? selectedItem[labelFieldName]
			: selectedItem),
			input
		);
	};

	const activateDropdown = async () => {
		if (open) return;
		$$invalidate(4, open = true);
		await tick();
		$$invalidate(7, input.innerHTML = "", input);
		$$invalidate(6, activeFacet = undefined);
		$$invalidate(2, filteredListItems = listItems);
		activateListItem(items.indexOf(selectedItem));
		input.focus();
	};

	const closeDropdown = () => {
		$$invalidate(4, open = false);
		onSelectedItemChanged();
		input.blur();
	};

	const toggleDropdown = () => open ? closeDropdown() : activateDropdown();

	const selectListItem = (listItem = filteredListItems[activeListItemIndex]) => {
		$$invalidate(17, selectedItem = listItem.item);
		closeDropdown();
	};

	const click_handler = ({ target }) => {
		if (open && !(dropdown.contains(target) || input.contains(target))) {
			closeDropdown();
		}
	};

	const keydown_handler = ({ key }) => {
		if (open && key === "Escape") closeDropdown();
	};

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(7, input);
		});
	}

	const keydown_handler_1 = ({ key }) => {
		switch (key) {
			case "ArrowDown":
				activateDropdown();
				activateListItem(activeListItemIndex + 1);
				break;
			case "ArrowUp":
				activateDropdown();
				activateListItem(activeListItemIndex - 1);
				break;
			case "PageDown":
				activateDropdown();
				activateListItem(activeListItemIndex + 15);
				break;
			case "PageUp":
				activateDropdown();
				activateListItem(activeListItemIndex - 15);
				break;
			case "Escape":
				closeDropdown();
				break;
			case "Enter":
				selectListItem();
				closeDropdown();
				break;
			default:
		}
	};

	const click_handler_1 = facet => {
		setActiveFacet(facet);
		input.focus();
	};

	const click_handler_2 = listItem => selectListItem(listItem);
	const pointerenter_handler = i => $$invalidate(5, activeListItemIndex = i);

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			list = $$value;
			$$invalidate(9, list);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			dropdown = $$value;
			$$invalidate(8, dropdown);
		});
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(18, items = $$props.items);
		if ("selectedItem" in $$props) $$invalidate(17, selectedItem = $$props.selectedItem);
		if ("labelFieldName" in $$props) $$invalidate(19, labelFieldName = $$props.labelFieldName);
		if ("searchFieldName" in $$props) $$invalidate(20, searchFieldName = $$props.searchFieldName);
		if ("facetFieldName" in $$props) $$invalidate(21, facetFieldName = $$props.facetFieldName);
		if ("postMarkup" in $$props) $$invalidate(0, postMarkup = $$props.postMarkup);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 262144) {
			/* eslint-disable no-unused-expressions, no-sequences */
			$: (items, prepareListItems());
		}

		if ($$self.$$.dirty[0] & /*selectedItem*/ 131072) {
			$: (selectedItem, onSelectedItemChanged());
		}
	};

	return [
		postMarkup,
		listItems,
		filteredListItems,
		facets,
		open,
		activeListItemIndex,
		activeFacet,
		input,
		dropdown,
		list,
		activateListItem,
		search,
		setActiveFacet,
		activateDropdown,
		closeDropdown,
		toggleDropdown,
		selectListItem,
		selectedItem,
		items,
		labelFieldName,
		searchFieldName,
		facetFieldName,
		click_handler,
		keydown_handler,
		span_binding,
		keydown_handler_1,
		click_handler_1,
		click_handler_2,
		pointerenter_handler,
		ul_binding,
		div1_binding
	];
}

class FilteredSelect extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				items: 18,
				selectedItem: 17,
				labelFieldName: 19,
				searchFieldName: 20,
				facetFieldName: 21,
				postMarkup: 0
			},
			[-1, -1]
		);
	}
}

export default FilteredSelect;